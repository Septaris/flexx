import sys
import json
import types

from ..pyscript import (py2js, JSConstant,
                        create_js_module, get_all_std_names, get_full_std_lib)

from .model import Model
from .asset import Asset
from . import logger


pyscript_types = type, types.FunctionType  # class or function
json_types = None.__class__, bool, int, float, str, tuple, list, dict

# The pyscript package does not deal with license headers,
# we add them to our assets here.
HEADER = 'Autogenerated code from Flexx. Code Subject to the BSD-2-clause license.'
HEADER = '/* %s */\n\n' % HEADER


# todo: __slots__

# In essense, the idea of modules is all about propagating dependencies:
#
# * In PyScript we detect unresolved dependencies in JS code, and move these up
#   the namespace stack.
# * The create_js_hasevents_class() function and ModelMeta class collect the
#   dependencies from the different code pieces.
# * In JSModule we resolve some dependencies and let other propagate into
#   module dependencies.
# * In the Bundle class, again some dependencies are resolved due to bundling,
#   and others propagate to dependencies between bundles.


def get_mod_name(ob):
    """ Get the module name of an object (the name of a module object or
    the name of the module in which the object is defined). Our naming
    differs slighly from Python's in that the module in ``foo/bar/__init__.py``
    would be named ``foo.bar.__init__``, which simplifies dependency handling
    for Flexx. Note that such modules only occur if stuff is actually defined
    in them.
    """
    if not isinstance(ob, types.ModuleType):
        ob = sys.modules[ob.__module__]
    name = ob.__name__
    if ob.__package__ == name:
        name += '.__init__'
    return name


class JSModule:
    """
    A JSModule object represents the JavaScript (and CSS) corresponding
    to a Python module, which either defines one or more Model classes,
    or PyScript transpilable functions or classes. Intended for internal
    use only.
    
    Modules are collected in a "store" which is simply a dictionary. The
    flexx asset system has this dict in ``app.assets.modules``.
    
    The module contains the JS corresponding to the variables that are
    marked as used (by calling the ``add_variable()`` method), and the
    variables that are used by the included JavaScript.
    
    The JS code includes: 
    
    * The JS code corresponding to all used Model classes defined in the module.
    * The transpiled JS from (PySript compatible) functions and classes that
      are defined in this module and marked as used.
    * Variables with json-compatible values that are used by JS in this module.
    * Imports of names from other modules.
    * ... unless this module defines ``__pyscript__ = True``, in which case
      the module is transpiled as a whole.
    
    A model also has dependencies:
    
    * The modules that define the base classes of the classes defined
      in this module.
    * The modules that define functions/classes that are used by this module.
    * Assets that are present in the module.
    
    Notes on how the Flexx asset system uses modules:
    
    The asset system will generate JSModule objects for all Python
    modules that define Model subclasses. Further, all imported Model
    classes are marked as used.
    
    The session is aware of the Model classes that it uses (initially)
    and their base classes, and can therefore determine what modules need
    to be loaded.
    """
    
    def __init__(self, name, store):
        if not isinstance(name, str):
            raise TypeError('JSModule needs a str name.')
        if not isinstance(store, dict):
            raise TypeError('JSModule needs a dict store.')
        
        # Resolve name of Python module
        py_name = name
        if name.endswith('.__init__'):
            py_name = name.rsplit('.', 1)[0]
        if py_name not in sys.modules:
            raise ValueError("Cannot find Python module coresponding to %s." % name)
        
        # Store module and name
        self._pymodule = sys.modules[py_name]
        self._name = name
        
        # Check if name matches the kind of module
        is_package = self._pymodule.__package__ == self._pymodule.__name__
        if is_package and not name.endswith('.__init__'):
            raise ValueError('Modules representing the __init__ of a package '
                             'should end with ".__init__".')
        elif not is_package and name.endswith('.__init__'):
            raise ValueError('Plain modules should not end with ".__init__".')
        
        # Self-register
        self._store = store
        if self.name in self._store:
            raise RuntimeError('Module %s already exists!' % self.name)
        self._store[self.name] = self
        
        # Bookkeeping content of the module
        self._provided_names = set()
        self._imported_names = set()
        # Stuff defined in this module (in JS)
        self._model_classes = []
        self._pyscript_code = []
        self._json_values = []
        # Dependencies
        self._deps = {}  # mod_name -> [mod_as_name, *imports]
        self._asset_deps = []  # todo: objects or names?
        # Caches
        self._js_cache = None
        self._css_cache = None
        
        if getattr(self._pymodule, '__pyscript__', False):
            # PyScript module; transpile as a whole
            js = py2js(self._pymodule, inline_stdlib=False, docstrings=False)
            self._pyscript_code.append(js)
            self._provided_names.update([n for n in js.meta['vars_defined']
                                         if not n.startswith('_')])
        else:
            # Regular module, can have assets
            self._scrape_dependencies()
            self._asset_deps = tuple(sorted(self._asset_deps, key=lambda x: x.i))
    
    def __repr__(self):
        return '<%s %s with %i definitions>' % (self.__class__.__name__,
                                                self.name,
                                                len(self._provided_names))
    
    @property
    def name(self):
        """ The (qualified) name of this module.
        """
        return self._name
    
    @property
    def deps(self):
        """ The set of dependencies (names of other modules) for this module.
        """
        return set(self._deps.keys())
    
    @property
    def asset_deps(self):
        """ A list of asset objects that this module depends on. """
        return self._asset_deps
    
    def _import(self, mod_name, name, as_name):
        """ Import a name from another module. This also ensures that the
        other module exists.
        """
        # Create module, if we must
        if mod_name == self.name:
            return self
        elif mod_name not in self._deps:
            if mod_name not in self._store:
                JSModule(mod_name, store=self._store)
        m = self._store[mod_name]
        # Define imports and if necessary, the name that we import
        imports = self._deps.setdefault(mod_name, [mod_name])
        if name:
            self._imported_names.add(as_name)
            m.add_variable(name)
            imports.append('%s as %s' % (name, as_name))
        return m
    
    def _scrape_dependencies(self):
        """ Collect assets defined in this module.
        """
        # todo: I am a tiny bit unsure whether this is the best way to bind Assets
        # Binding an asset to a module has the advantage that an asset is global,
        # but we can still detect when its used (i.e. when the module is used).
        for name in sorted(dir(self._pymodule)):
            if name.startswith('__'):
                continue
            elif name in self._imported_names:
                continue
            
            val = getattr(self._pymodule, name)
            
            if isinstance(val, Asset):
                self._imported_names.add(name)
                self._asset_deps.append(val)
    
    @property
    def variables(self):
        """ The names of variables provided by this module.
        A name passed to add_variable, might not end up in this list
        if its imported into this module rather than defined here.
        """
        return self._provided_names
    
    def add_variable(self, name):
        """ Mark the variable with the given name as used by JavaScript.
        The corresponding object must be a module, Model, class or function,
        or a json serializable value.
        
        If the object is defined here (or a json value) it will add JS to
        this module. Otherwise this module will import the name from 
        another module.
        """
        
        if name in self._provided_names or name in self._imported_names:
            return
        if getattr(self._pymodule, '__pyscript__', False):
            return  # everything is transpiled and exported already
        
        # Try getting value. We warn if there is no variable to match, but
        # if we do find a value we're either including it or raising an error
        try:
            val = getattr(self._pymodule, name)
        except AttributeError:
            logger.warn('Module %s does not have variable %r.' % (self.name, name))
            return
        
        if isinstance(val, JSConstant):
            return  # It's a deliberate stub!
        
        # Mark dirty
        self._js_cache = self._css_cache = None
        
        if isinstance(val, types.ModuleType):
            # Modules as a whole can be converted if its a PyScript module
            if getattr(val, '__pyscript__', False):
                self._import(val.__name__, None, None)
                self._deps[val.__name__][0] = name  # set/overwrite as-name
            else:
                t = 'Cannot use module %s directly in JS unless it defines %s.'
                raise ValueError(t % (val.__name__, '"__pyscript__"'))
        
        elif isinstance(val, type) and issubclass(val, Model):
            # Model class; we know that we can get the JS for this
            if val.__jsmodule__ == self.name:
                # Define here
                self._provided_names.add(name)
                self._model_classes.append(val)
                # Recurse
                self._collect_dependencies_from_bases(val)
                self._collect_dependencies(val.JS.CODE.meta['vars_unknown'])
            else:
                # Import from another module
                # not needed per see; bound via window.flexx.classes
                self._import(val.__jsmodule__, val.__name__, name)
        
        elif isinstance(val, pyscript_types) and hasattr(val, '__module__'):
            # Looks like something we can convert using PyScript
            mod_name = get_mod_name(val)
            if mod_name == self.name:
                # Define here
                try:
                    js = py2js(val, inline_stdlib=False, docstrings=False)
                except Exception as err:
                    t = 'JS uses %s.%s but cannot transpile it with PyScript:\n%s'
                    raise ValueError(t % (self.name, name, str(err)))
                self._provided_names.add(name)
                self._pyscript_code.append(js)
                # Recurse
                if isinstance(val, type):
                    self._collect_dependencies_from_bases(val)
                self._collect_dependencies(js.meta['vars_unknown'])
            else:
                # Import from another module
                self._import(mod_name, val.__name__, name)
        
        elif isinstance(val, json_types):
            # Looks like something we can serialize
            # Note: we have no way to determine where it is defined
            # todo: or do we, if we analyze the source, check other modules, etc?
            try:
                js = json.dumps(val)
            except Exception as err:
                t = 'JS uses %s.%s but cannot serialize that value:\n%s'
                raise ValueError(t % (self.name, name, str(err)))
            self._provided_names.add(name)
            self._json_values.append('var %s = %s;' % (name, js))
        
        else:
            # Cannot convert to JS
            t = 'JS uses %s.%s but cannot convert %s to JS.'
            raise ValueError(t % (self.name, name, val.__class__))
    
    def _collect_dependencies(self, names):
        """
        Collect dependencies corresponding to names used in the JS.
        """
        for name in reversed(sorted(names)):
            self.add_variable(name)
    
    def _collect_dependencies_from_bases(self, cls):
        """
        Collect dependencies based on the base classes of a class.
        """
        if cls is Model:
            return
        if len(cls.__bases__) != 1:  # pragma: no cover
            raise TypeError('PyScript classes (currently) do not support multiple inheritance.')
        for base_cls in cls.__bases__:
            if base_cls is object:
                continue
            m = self._import(get_mod_name(base_cls), None, None)
            m.add_variable(base_cls.__name__)  # note: m can be self, which is ok
    
    def get_js(self):
        """ Get the JS code for this module.
        """
        if self._js_cache is None:
            # Collect JS and sort by linenr
            js = [cls.JS.CODE for cls in self._model_classes] + self._pyscript_code
            js.sort(key=lambda x: x.meta['linenr'])
            # todo: collect stdlib funcs here
            # Insert serialized values
            js.insert(0, '')
            for line in reversed(sorted(self._json_values)):
                js.insert(0, line)
            js.insert(0, '')
            # Prepare imports and exports
            exports = tuple(sorted(self._provided_names))
            imports = ['pyscript-std.js as _py']
            # Handle dependency imports
            for dep_name in reversed(sorted(self._deps)):
                names = self._deps[dep_name]
                mod_name = names[0].replace('.', '_')  # can still be dep_name
                imports.append(dep_name + ' as ' + mod_name)
                for name in names[1:]:
                    as_name = name
                    if ' as ' in name:
                        name, _, as_name = name.partition(' as ')
                    pieces = ['%s = %s.%s' % (as_name, mod_name, name)]
                    js.insert(0, 'var ' + (', '.join(pieces)) + ';')
            # Import stdlib
            # todo: either include only std of what we use, or use _py.xxx
            func_names, method_names = get_all_std_names()
            pre1 = ', '.join(['%s = _py.%s' % (n, n) for n in func_names])
            pre2 = ', '.join(['%s = _py.%s' % (n, n) for n in method_names])
            js.insert(0, 'var %s;\nvar %s;' % (pre1, pre2))
            # Create module
            self._js_cache = create_js_module(self.name, '\n\n'.join(js),
                                              imports, exports, 'amd-flexx')
            self._js_cache = HEADER + '\n\n' + self._js_cache  # Add license header
        return self._js_cache
    
    def get_css(self):
        """ Get the CSS code for this module.
        """
        if self._css_cache is None:
            css = []
            sorter = lambda x: x.JS.CODE.meta['linenr']
            for cls in sorted(self._model_classes, key=sorter):
                css.append(cls.CSS)
            self._css_cache = '\n\n'.join(css)
        return self._css_cache
